// AUTOMATICALY GENERATED FILE, see cooresponding .ts file
// Copyright (c) IPython Development Team.
// Distributed under the terms of the Modified BSD License.
define(["require", "exports", 'jquery', 'base/js/dialog', 'base/js/utils'], function (require, exports, $, dialog, utils) {
    "use strict";
    var default_config = {
        /**
         * Google API Client ID
         * @type {string}
         **/
        CLIENT_ID: '763546234320-uvcktfp0udklafjqv00qjgivpjh0t33p.apps.googleusercontent.com',
        APP_ID: '763546234320',
        FILE_SCOPE: true,
        METADATA_SCOPE: true,
    };
    /**
     * Google API App ID
     * @type {string}
     */
    exports.APP_ID = '763546234320';
    /**
     * OAuth scope for accessing specific files that have been opened/created
     * by this app.
     * @type {string}
     */
    var FILES_OAUTH_SCOPE = 'https://www.googleapis.com/auth/drive.file';
    /**
     * OAuth scope for accessing file metadata (for tree view)
     * @type {string}
     */
    var METADATA_OAUTH_SCOPE = 'https://www.googleapis.com/auth/drive.readonly.metadata';
    /**
     * Error message for origin mismatch error.
     * @type {string}
     */
    var ORIGIN_MISMATCH_MSG = ('An origin_mismatch error has been receieved from Google Drive.  This' +
        ' may be beacuse you are running IPython notebook on a URL other than' +
        ' 127.0.0.1 or a port that is not in the range 8888-8899.  Please see' +
        ' https://github.com/jupyter/jupyter-drive/issues/21 for more details');
    /**
     * Helper functions
     */
    /**
     * Perform an authenticated download.
     * @param {string} url The download URL.
     * @return {Promise} resolved with the contents of the file, or rejected
     *     with an Error.
     */
    exports.download = function (url) {
        // Sends request to load file to drive.
        var token = gapi.auth.getToken().access_token;
        var settings = { headers: { 'Authorization': 'Bearer ' + token } };
        return utils.promising_ajax(url, settings);
    };
    /**
     * Wrap a Google API result as an Promise, which is immediate resolved
     * or rejected based on whether an error is detected.
     * @param {Object} result The result of a Google API call, as returned
     *     by a request.execute method.
     * @return {Promise} The result wrapped as a promise.
     */
    var wrap_result = function (result) {
        if (!result) {
            // Error type 1: result is False
            var error = new Error('Unknown error during Google API call');
            error.name = 'GapiError';
            return Promise.reject(error);
        }
        else if (result['error']) {
            // Error type 2: an error resource (see
            // https://developers.google.com/drive/web/handle-errors)
            var error = new Error(result['error']['message']);
            error['gapi_error'] = result;
            return Promise.reject(error);
        }
        else {
            return Promise.resolve(result);
        }
    };
    /**
     * Executes a Google API request.  This wraps the request.execute() method,
     * by returning a Promise, which may be resolved or rejected.  The raw
     * return value of execute() has errors detected, and errors are wrapped as
     * an Error object.
     *
     * Typical usage:
     * var request = gapi.client.drive.files.get({
     *     'fileId': fileId
     * });
     * execute(request, success, error);
     *
     * @param {Object} request The request, generated by the Google JavaScript
     *     client API.
     * @param {boolean} [attemptReauth=true] Boolean indicating whether
     *     re-authorization should be attempted if a 401 status is returned.
     * @return {Promise} Fullfilled with the result on success, or the
     *     result wrapped as an Error on error.
     */
    exports.execute = function (request, attemptReauth) {
        if (attemptReauth === void 0) { attemptReauth = true; }
        return new Promise(function (resolve, reject) {
            request.execute(function (result) {
                /* Special case: although the user authorizes jupyter-drive on first
                 * load, the authorization has a timeout. (Google seem to use 3600
                 * seconds == 1 hour as default.) After this time, even
                 * authenticated requests will fail. If we have failed with a 401,
                 * attempt to execute again after authorizing once more.
                 */
                if (attemptReauth && (result.statusCode === 401)) {
                    console.warn("[gapiutils.js] Got 401 status. Will re-authorize.");
                    resolve(_conf_prm.then(function (config) {
                        return authorize(false, config);
                    }).then(exports.execute(request, false)));
                }
                else {
                    resolve(wrap_result(result));
                }
            });
        });
    };
    /**
     * Authorization and Loading Google API
     *
     * Utilities for doing OAuth flow with the Google API.
     */
    /**
     * Utility method that polls for a condition to hold.
     * @param {Function} condition Function called with no args, that returns
     *     true when the condition is fullfilled
     * @param {Number} interval Polling interval in milliseconds
     * @return Promise fullfilled when condition holds
     */
    var poll = function (condition, interval) {
        return new Promise(function (resolve, reject) {
            var polling_function = function () {
                if (condition()) {
                    resolve();
                }
                else {
                    setTimeout(polling_function, interval);
                }
            };
            polling_function();
        });
    };
    /**
     * (Internal use only) Returns a promise that is fullfilled when client
     * library loads.
     * @return {Promise} empty value on success or error on failure.
     */
    var load_gapi_1 = function () {
        return Promise.resolve($.getScript('https://apis.google.com/js/client.js'))
            .then(function () {
            // poll every 100ms until window.gapi and gapi.client exist.
            return poll(function () { return !!(window.gapi && gapi.client); }, 100);
        }, utils.wrap_ajax_error);
    };
    /**
     * (Internal use only) Returns a promise fullfilled when client library
     * loads.
     */
    var load_gapi_2 = function (d) {
        return new Promise(function (resolve, reject) {
            gapi.load('auth:client,drive-realtime,drive-share,picker', function () {
                gapi.client.load('drive', 'v2', resolve);
            });
        });
    };
    /* {set,clear}Timeout handle for the authorization refresh timeout. */
    var _authorizeTimeout = null;
    /**
     * Returns a promise fullfilled when the Google API has authorized.
     * @param {boolean} opt_withPopup If true, display popup without first
     *     trying to authorize without a popup.
     */
    var authorize = function (opt_withPopup, conf) {
        var config = $.extend({}, default_config, (conf.data || {})['gdrive']);
        var scope = [];
        if (config.FILE_SCOPE) {
            scope.push(FILES_OAUTH_SCOPE);
        }
        if (config.METADATA_SCOPE) {
            scope.push(METADATA_OAUTH_SCOPE);
        }
        var authorize_internal = function () {
            return new Promise(function (resolve, reject) {
                gapi.auth.authorize({
                    'client_id': config.CLIENT_ID,
                    'scope': scope,
                    'immediate': !opt_withPopup
                }, function (result) {
                    // Google API auth tokens have an inbuilt expiry, usually 3600
                    // seconds == 1 hour. The Google-blessed approach to long-lived
                    // web apps is to refresh the auth token after 45 minutes (===
                    // 3/4 of expirty time). If we are given an expiry time (and if
                    // that expiry time is numeric) set a timeout to refresh the
                    // token.
                    if (result.expires_in && (+result.expires_in > 0)) {
                        // Clear any existing timeout
                        if (_authorizeTimeout !== null) {
                            clearTimeout(_authorizeTimeout);
                        }
                        // Set a reauthorization timeout to be 3/4 of expires_in.
                        // Note that expires_in is in seconds and setTimeout takes a
                        // milliseconds argument, hence the multiplication by 750.
                        _authorizeTimeout = setTimeout(function () {
                            console.log("Refreshing Google API token.");
                            _authorizeTimeout = null;
                            _conf_prm.then(function (config) {
                                authorize(false, config);
                            });
                        }, 750 * (+result.expires_in));
                    }
                    resolve(wrap_result(result));
                });
            });
        };
        if (opt_withPopup) {
            return new Promise(function (resolve, reject) {
                // Gets user to initiate the authorization with a dialog,
                // to prevent popup blockers.
                var options = {
                    title: 'Authentication needed',
                    body: ('Accessing Google Drive requires authentication.  Click'
                        + ' ok to proceed.'),
                    buttons: {
                        'ok': { click: function () { resolve(authorize_internal()); },
                        },
                        'cancel': { click: reject }
                    }
                };
                dialog.modal(options);
            });
        }
        else {
            // Return result of authorize, trying again with withPopup=true
            // in case of failure.
            return authorize_internal().catch(function (error) {
                if (error['gapi_error'] &&
                    error['gapi_error']['error_subtype'] == 'origin_mismatch') {
                    // An origin mismatch error almost always indicates that the user
                    // has tried to launch IPython from a port or origin unknown to
                    // the client ID.  Therefore inform them of this.
                    var _error = new Error(ORIGIN_MISMATCH_MSG);
                    _error.name = 'GapiError';
                    return Promise.reject(_error);
                }
                return authorize(true, { 'data': { 'gdrive': config } });
            });
        }
    };
    var _handle = { resolve: function (any) { return Object; } };
    var _conf_prm = new Promise(function (resolve) {
        _handle.resolve = resolve;
    });
    /**
     * calling config with conf, results in the promise _conf_prm being resolved with conf.
     * This then triggers the rest of the gapi loading
     **/
    exports.config = function (conf) {
        _handle.resolve(conf);
    };
    /**
     * Promise fullfilled when gapi is loaded, and authorization is complete.
     */
    var load_gapi = load_gapi_1().then(load_gapi_2);
    exports.gapi_ready = Promise.all([load_gapi, _conf_prm]).then(function (values) {
        var config = values[1];
        return authorize(null, config);
    });
});

//# sourceMappingURL=gapiutils.js.map
